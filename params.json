{"name":"Zeropush-java","tagline":"A java library for the ZeroPush API","body":"## ZeroPush Java client\r\n\r\nThis repository is the home of the ZeroPush client in Java.\r\n\r\nIn order to use Java client in your Java EE / SE application, you have to use this dependency in your Maven project:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.zeropush</groupId>\r\n    <artifactId>zeropush</artifactId>\r\n    <version><!-- prefered version --></version>\r\n</dependency>\r\n```\r\n\r\nIn order to use Java client in Android, you have to use this dependency \r\nin your Maven projects:\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>com.zeropush</groupId>\r\n    <artifactId>zeropush-android</artifactId>\r\n    <version><!-- prefered version --></version>\r\n</dependency>\r\n```\r\n\r\n## Installation\r\n\r\nThis project is managed with Maven 3. In order to install artifacts without tests, you have to execute this:\r\n\r\n```shell\r\n$ mvn clean install -DskipTests\r\n```\r\n\r\nNot specifying `skipTests` property will lead to test execution as well. You have to follow https://github.com/ZeroPush/ZeroPush-java#how-to-execute-internal-tests in order to be able to execute tests.\r\n\r\nNote that this installation procedure holds only for snapshot version of the library. While using released version, it will be automatically downloaded from Maven Central.\r\n\r\n## Usage\r\n\r\nThe only entry point to the client is via class `com.zeropush.ZeroPush`.\r\n\r\nZeroPush Java client is very intuitive and easy to use. The client is able to communicate with every ZeroPush API server endpoint. You can also send push notifications from the client to registered devices hence you can use this library from your Java backends.\r\n\r\nThe usage of the client is exactly the same for Java EE / SE and Android.\r\n\r\nWhile using ZeroPush client, every endpoint call will result in a Java oneliner since we are using fluent API heavily.\r\n\r\n### Configuration of ZeroPush client\r\n\r\n`ZeroPush` uses default configuration when it is not set via its `setConfiguration` method.\r\n\r\nBefore any interaction with ZeroPush server, you have to specify server and application tokens like this:\r\n\r\n```java\r\nZeroPush.getConfiguration().setServerToken(\"serve token\");\r\nZeroPush.getConfiguration().setApplicationToken(\"application token\");\r\n```\r\n\r\nYou can set both keys at one like this:\r\n\r\n```java\r\nZeroPush.getConfiguration().setTokens(serverKey, applicationKey);\r\n```\r\n\r\nSome ZeroPush REST endpoints are able to operate with both tokens. Internally, the token which will be used is obtained via `getAuthToken()` method on `ZeroPushConfiguration`. You can decide which token will be returned by this method by calling `preferServerToken()` or `preferAppToken()` method. By doing so, such prefered key will be used every time when it is not clear which token should be used. By default, server key is returned.\r\n\r\n### Thread safety\r\n\r\nZeroPush client is designed to be thread safe. You can use `ZeroPush` client in two separate threads. `ZeroPushConfiguration` is persisted in `ThreadLocal` so invocations of `ZeroPush` on different threads will use different configurations.\r\n\r\n### Sending of notifications\r\n\r\nThe sending of a  push notification is in general divided into two steps. Firstly, you have to build your notification to be sent. The second step is to actually send it. Additionally, you can decide whether you want to broadcast the built notification or whether you want to broadcast it only to some channel.\r\n\r\nThere are builders for every notification type (Android, iOS/Macs, Safari). For the brevity, only Android notification will be shown here. All other notification types are used similarly.\r\n\r\nThe notification builders copy all options described https://zeropush.com/documentation/api_reference#notify. Notification builders have setters for every possible option for particular notification type. There are `IOSPushNotification` and `SafariPushNotification` classes for notifications meant to be sent to iOS/Macs and Safari respectively.\r\n\r\nBuilding and sending of an Android notification:\r\n\r\n```java\r\nZeroPushNotification boardingNotification = new AndroidPushNotification.Builder()\r\n    .addDeviceToken(DEVICE_TOKEN)\r\n    .addDatum(\"alert\", \"Now Boarding\")\r\n    .addDatum(\"username\", \"fred.droid\")\r\n    .build();\r\n\r\n// A built notification is actually sent like this:\r\n\r\nZeroPush.notification(boardingNotification).send();\r\n\r\n// In order to broadcast it, you have to set broadcasting flag:\r\n\r\nZeroPush.notification(boardingNotification).broadcast().send();\r\n\r\n// You may want to broadcast it only for some channel like this:\r\n\r\nZeroPush.notification(boardingNotification).broadcast(\"channel_name\").send();\r\n```\r\n\r\nNotification for iOS would be constructed very similarly, for example:\r\n\r\n```java\r\nZeroPushNotification boardingNotification = new IOSPushNotification.Builder()\r\n    .addDeviceToken(DEVICE_TOKEN)\r\n    .alert(\"Now Boarding\")\r\n    .badge(\"+1\")\r\n    .category(\"category1\")\r\n    .contentAvailable()\r\n    .build();\r\n\r\nZeroPush.notification(boardingNotification).send();    \r\n```\r\n\r\nFor iOS/Mac notifications, you can provide `alert` String by two means. The first one is to specify it directly as a String \r\nas shown above. The second option is to use `AlertJSON.Builder` and build it programmatically like this:\r\n\r\n```java\r\nString alertString = new AlertJSON.Builder()\r\n    .locArgs(\"locArc1\", \"locArc2\")\r\n    .body(\"hello\")\r\n    .launchImage(\"image.png\")\r\n    .build();\r\n```\r\n\r\nPass such constructed `alertString` to `alert(String)` method on `IOSPushNotification.Builder`.\r\n\r\n### Quota checking\r\n\r\nYou can check your quotas as well when you execute `getQuota()` method on an object returned while executing `send()`. Quotas \r\nare read from HTTP headers which are returned to client after the notification sending. \r\n\r\n### Communication with ZeroPush REST endpoints\r\n\r\nVerification of credentials:\r\n\r\n```java\r\nZeroPush.verification().credentials(\"your key\").execute();\r\n```\r\n\r\nRegistration of a device:\r\n\r\n```java\r\n// registering\r\n\r\nZeroPush.registration().register(\"device token\").execute();\r\n\r\n// unregistering\r\n\r\nZeroPush.registration().unregister(\"device token\").execute();\r\n```\r\n\r\nSubscription of a device:\r\n\r\n```java\r\n// subscription\r\n\r\nZeroPush.subscription().subscribe(\"token\", \"channel\").execute();\r\n\r\n// unsubscription\r\n\r\nZeroPush.subscription().unsubscribe(\"token\", \"channel\").execute();\r\n```\r\n\r\nGetting of inactive devices:\r\n\r\n```java\r\nZeroPush.inactivity().get().execute();\r\n```\r\n\r\nSetting of a badge:\r\n\r\n```java\r\nZeroPush.badge().setBadge(\"device token\", <integer>).execute();\r\n```\r\n\r\nGetting of a single device:\r\n\r\n```java\r\nDevice dev = ZeroPush.devices().get(\"device token\").execute().getDevice();\r\n```\r\n\r\nGetting of devices:\r\n\r\n```java\r\nList<Device> devices = ZeroPush.devices().get().execute().getDevices();\r\n```\r\n\r\nReplacing of channels for some device token:\r\n\r\n```java\r\nZeroPush.devices().replaceChannels(\"token\", array of channels).execute();\r\n```\r\n\r\nAppending channels to some device token:\r\n\r\n```java\r\nZeroPush.devices().appendChannels(\"token\", array of channels).execute();\r\n```\r\n\r\nGetting of single channel:\r\n\r\n```java\r\nChannel ch = ZeroPush.channels().get(\"channel\").execute().getChannel();\r\n```\r\n\r\nGetting of all channels:\r\n\r\n```java\r\nList<Channel> channels = ZeroPush.channels().get().execute().getChannels();\r\n```\r\n\r\nUnsubscribe all devices and delete this channel:\r\n\r\n```java\r\nZeroPush.channels().delete(\"channel_name\").execute();\r\n```\r\n\r\n### Inspection of a response from the ZeroPush server\r\n\r\nWhen you call `execute()` method on ZeroPush oneliner, you get object which represents the actual response from ZeroPush server. You can get error messages via `getResponseError()` \r\nand you can inspect returned status code of the response as well by `getStatusCode()` on every endpoint response object.\r\n\r\n### Reaching ZeroPush service behind a proxy\r\n\r\nIn case you are behind a proxy server and you want to reach ZeroPush API server, you have to create `Proxy` object and set it to `ZeroPushConfiguration` like the following:\r\n\r\n```java\r\nProxy proxy = new ZeroPushConfiguration.ProxyBuilder()\r\n    .withHostname(\"127.0.0.1\") // by default \"localhost\"\r\n    .withPort(8888) // by default \"8080\"\r\n    .build();\r\n```\r\n\r\nAfter building `Proxy`, pass it into the configuration:\r\n\r\n```java\r\nZeroPush.getConfiguration().setProxy(proxy);\r\n```\r\n\r\nFrom now on, all communication with ZeroPush API service will be executed via proxy.\r\n\r\n### Using client in Android environment\r\n\r\nWhen you use client in Android, you have to provide your own asynchronicity mechanism. If you use it in UI thread, there can be `NetworkOnMainThreadException` thrown. You can use e.g. `AsyncTask` class to wrap ZeroPush client into it.\r\n\r\n### How to generate JavaDoc?\r\n\r\n```shell\r\n$ mvn javadoc:aggregate\r\n```\r\n\r\nYou find generated JavaDocs in root directory in `target/site/apidocs/index.html`.\r\n\r\n### How to execute internal tests?\r\n\r\nImplementation artifact contains integration tests. You can execute these tests in two ways.\r\n\r\nThe first option:\r\n\r\n```shell\r\n$ mvn clean test\r\n```\r\n\r\nTests use server token and app token from your ZeroPush web console. You have to specify them in order to be able to execute tests. These tests will operate against the application with the specified keys.\r\n\r\nKeys are saved in property file located in `src/test/resources/zeropush.properties`. The content of the file has to be like this:\r\n\r\n```shell\r\nzeropush.token.server=<your server token>\r\nzeropush.token.app=<your app token>\r\n```\r\n\r\nThe second option is to specify tokens on a command line so these credentials will not be saved in property file (hence not committed).\r\n\r\n```shell\r\n$ mvn clean test -Dzeropush.token.server=<token> -Dzeropush.token.app=<token>\r\n```\r\n\r\nIn case you execute tests by the second option and there are tokens specified in property file as well, system properties will override these in property file. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}